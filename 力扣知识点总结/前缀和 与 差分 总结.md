未来的我，请注意下标细节。
# 前缀和
前缀和的主要用途：求子数组或者子矩阵的和, 有时可以搭配哈希表使用，高效枚举一些题目。

前缀和分为：
- 一维前缀和 ：用途是求子数组的和，可以前缀和一个一维的数列，例如矩阵的一行，一列，对角线都可以用。
- 二维前缀和 ：用途是求子矩阵的和。

如果题目给的是一个字符串，可以将这个字符串抽象为一个数列，例如元音字母抽象为1，其他字母抽象为-1，实际情况根据题目调整。

如果题目给的是一个数列，不一定是对原本的数列进行前缀和，而是将这个数列转化为另一个数列进行前缀和，例如 nums[i] > 8 时，将其抽象为1，nums[i] <= 8时，将其抽象为 -1，实际情况根据题目调整。

前缀和公式：

一维 ：
``` cpp
//写法1
//s[i] 表示的是 nums [0, i - 1] 的和
//s[0] = 0
for(int i = 0; i < n; i++)
{
	s[i + 1] = s[i] + nums[i]; 
}

//写法2
//s[i] 表示的是 nums [0, i] 的和
s[0] = nums[0];
for(int i = 1; i < n; i++)
{
	s[i] = s[i - 1] + nums[i];
}

```

这个写法将前缀和整体右移了一位，避免了数组下标越界的问题。
例子：
要求区间 nums [l, r] 的和：
- 当使用写法2时，使用公式s[r] - s[l - 1]
- 当使用写法1时，使用公式s[r + 1] - s[l]
显然，当l = 0时，写法2的公式会出现下标越界的问题，所以写题时一般用写法1

注意：写前缀和时，要时刻提醒自己s[i]的定义，这样写题下标才不会乱。

二维 ：
```cpp
//写法1
//s[i][j] 表示的是 从(0, 0) 到 (i - 1, j - 1) 左上角矩阵内所有数和
for(int i = 0; i < m; i++)
{
	for(int j = 0; j < n; j++)
	{
		s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + nums[i][j];
	}
}

//写法2
//s[i][j] 表示的是从 (0, 0) 到 (i, j) 左上角矩阵内所有数的和
```

要求子矩阵的和 ：
设子矩阵的最左上角元素的坐标是(x1, y1)， 最右下角元素的坐标是(x2, y2)，脑子里要有图
```
sum = s[x2 + 1][y2 + 1] - s[x2 + 1][y1] - s[x1][y2 + 1] + s[x1][x2];
```

# 差分
![[差分.png]]