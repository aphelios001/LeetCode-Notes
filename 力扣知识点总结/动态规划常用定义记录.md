动态规划也是有套路的：单个数组或者字符串要用动态规划时，可以把动态规划 `dp[i]` 定义为 `nums[0:i]` 中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 `dp[i][j]` ，其含义是在 `A[0:i]` 与 `B[0:j]` 之间匹配得到的想要的结果。

爬楼梯: `f[i]` : 爬到第i个台阶的方案数
打家劫舍: `f[i]` : 已经考虑了nums[0]到nums[i]的最大利润
最大子数组和：`f[i]` : 以nums[i]结尾的子数组的最大和
背包问题（选或不选）: `f[i][j]`: 对于前i个物品，能否凑成金额 j / 凑成金额 j 的最小(最大)数量
最长公共子序列：`f[i][j]`:考虑字符串s的前i个字符，字符串t的前j个字符，得到的最大公共子序列长度。
以上都是相邻元素无关系，用选或不选的做法。

最长递增子序列：`f[i]`: 以`nums[i]`结尾的最长递增子序列的长度，因为相邻元素有关系（递增），用枚举选哪个更好。

考虑以`nums[i]`开头，以`nums[i]`结尾，从`nums[0]`到`nums[i]`，等等
等待补充

未来的我，不会的话，回力扣看看以前怎么定义的哦。

### 动态规划的通用思路与核心套路

动态规划的本质思想是**分治**与**记忆化**。它将一个复杂的大问题分解成一连串更小的、可重复的子问题，然后将子问题的解存储起来，避免重复计算，从而高效地找到大问题的最优解。

你总结的套路非常经典，可以概括为以下两种主要模式：

---

### 模式一：单序列动态规划 (一维 DP)

当问题只涉及一个数组、一个字符串或一个序列时，我们通常使用一维的 `dp` 数组。

**核心定义**：`dp[i]` 通常表示**在考虑到 `nums[i]` 这个元素时**，原问题的某个子问题的最优解。

这个“考虑到”非常关键，它可以演变成两种主流定义：

1. **“从 `0` 到 `i`” 范围的最优解**：`dp[i]` 的值代表了子数组/子序列 `nums[0...i]` 的最优解。
    
2. **“以 `i` 结尾” 的最优解**：`dp[i]` 的值代表了所有**必须包含 `nums[i]`** 的子结构中的最优解。
    

#### 经典范例

**1. 爬楼梯**

- **问题描述**: 总共有 n 级台阶，每次可以爬 1 级或 2 级，问爬到第 n 级台阶共有多少种不同的方法？
    
- **状态定义**: `dp[i]` 表示爬到第 `i` 级台阶的总方案数。
    
- **状态转移**: 到达第 `i` 级的方法，可以是从第 `i-1` 级爬一步上来，也可以是从第 `i-2` 级爬两步上来。因此，`dp[i] = dp[i-1] + dp[i-2]`。
    
- **定义类型**: “从 `0` 到 `i`” 的范围最优解（这里是方案总数）。
    

**2. 打家劫舍**

- **问题描述**: 在一条直线上有一排房子，不能抢劫相邻的房子，求能抢到的最大金额。
    
- **状态定义**: `dp[i]` 表示考虑前 `i+1` 个房子 (`nums[0]` 到 `nums[i]`)，所能获得的最大利润。
    
- **状态转移**: 对于第 `i` 个房子，我们有两种选择：
    
    - **不抢**: 那么最大利润就是抢到第 `i-1` 个房子时的利润，即 `dp[i-1]`。
        
    - **抢**: 那么就不能抢第 `i-1` 个房子，最大利润是 `nums[i]` 加上抢到第 `i-2` 个房子时的利润，即 `nums[i] + dp[i-2]`。
        
    - 所以，`dp[i] = max(dp[i-1], nums[i] + dp[i-2])`。
        
- **定义类型**: “从 `0` 到 `i`” 的范围最优解。
    

**3. 最大子数组和**

- **问题描述**: 在一个数组中，找到一个具有最大和的连续子数组。
    
- **状态定义**: `dp[i]` 表示以 `nums[i]` **结尾**的连续子数组的最大和。
    
- **状态转移**: 对于以 `nums[i]` 结尾的子数组，它的最大和有两种可能：
    
    - **自成一派**: 子数组只包含 `nums[i]` 本身。
        
    - **加入前者**: 与前面以 `nums[i-1]` 结尾的最大和子数组 `dp[i-1]` 连接起来。
        
    - 所以，`dp[i] = max(nums[i], dp[i-1] + nums[i])`。
        
- **定义类型**: “以 `i` 结尾” 的最优解。**注意**：最终结果不是 `dp[n-1]`，而是整个 `dp` 数组中的最大值 `max(dp)`。
    

---

### 模式二：双序列动态规划 (二维 DP)

当问题涉及两个数组、两个字符串或两个序列时，我们通常需要一个二维的 `dp` 数组来记录状态。

**核心定义**：`dp[i][j]` 通常表示在第一个序列的前 `i` 个元素 (`A[0...i-1]`) 和第二个序列的前 `j` 个元素 (`B[0...j-1]`) 的范围内，问题的最优解。

#### 经典范例

**1. 最长公共子序列 (LCS)**

- **问题描述**: 找出两个字符串 `s1` 和 `s2` 的最长公共子序列的长度。
    
- **状态定义**: `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符 (`s1[0...i-1]`) 与字符串 `s2` 的前 `j` 个字符 (`s2[0...j-1]`) 的最长公共子序列的长度。
    
- **状态转移**:
    
    - 如果 `s1[i-1] == s2[j-1]`，说明找到了一个新的公共字符，长度加一：`dp[i][j] = dp[i-1][j-1] + 1`。
        
    - 如果 `s1[i-1] != s2[j-1]`，说明 `s1[i-1]` 和 `s2[j-1]` 不可能同时出现在LCS的末尾，需要退一步，取二者之中的最优解：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
        

**2. 背包问题 (0-1背包)**

- **问题描述**: 有 N 个物品和一个容量为 W 的背包。第 `i` 个物品的重量是 `weight[i]`，价值是 `value[i]`。求解将哪些物品装入背包，可使这些物品总重量不超过背包容量，且总价值最大。
    
- **状态定义**: `dp[i][j]` 表示从前 `i` 个物品中任意选择，放入容量为 `j` 的背包中所能获得的最大价值。
- **变式**：
- `dp[i][j]`: (能否) 从`nums[0]`到`nums[i]` 选出一个子序列，其和恰好为 j 的(最少数量)
    
- **状态转移**: 对于第 `i` 个物品，我们有两种选择：
    
    - **不放入背包**: 价值与只考虑前 `i-1` 个物品时一样：`dp[i-1][j]`。
        
    - **放入背包** (前提是放得下 `j >= weight[i-1]`)：价值为第 `i` 个物品的价值加上在前 `i-1` 个物品中，放入容量为 `j - weight[i-1]` 的背包的价值：`value[i-1] + dp[i-1][j - weight[i-1]]`。
        
    - 所以，`dp[i][j] = max(不放入价值, 放入价值)`。
        


**可以继续补充的思路**：

- **区间 DP**: `dp[i][j]` 定义为在区间 `[i, j]` 上的最优解。例如，戳气球问题。
    
- **状态压缩 DP**: 当状态的某个维度很小（例如 `n <= 20`）时，可以用一个二进制数来表示这个维度的所有状态。
    
- **数位 DP**: `dp[i][...]` 定义为考虑到从高到低的第 `i` 位时，满足特定条件的数字个数。
    

希望这份整理对你有帮助！你已经走在掌握动态规划的正确道路上了。