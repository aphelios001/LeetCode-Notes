未来的我，请好好回忆：
0、分析问题，如何获得答案？是否是多个问题的结果加起来或乘起来？据此找到关键问题。（关键问题： 可以用动态规划轻易解决的问题）
1、尝试不同的状态定义。（很重要）试试以 i 开始，以 i 结束，前 i 个，等等
2、尝试根据状态定义写出状态转移方程。
3、找到边界条件。

如果用记忆化搜索，请注意：
记忆化数组的值初始化为-1，代表未访问过，初始化为0可能会超时。见下。
**注意**：memo 数组的**初始值**一定不能等于要记忆化的值！例如初始值设置为 0，并且要记忆化的 dfs(i) 也等于 0，那就没法判断 0 到底表示第一次遇到这个状态，还是表示之前遇到过了，从而导致记忆化失效。一般把初始值设置为 −1。

初学者：实在没思路，试试先写出递归->记忆化搜索->翻译成递推->空间复杂度优化。
有些题熟练之后可以直接写递推。如最大子数组和等。

**动态规划技巧总结：**
二维dp，一般将f(i, j)的下标整体 + 1，整体向右下角移动一行一列(好像和前缀和方法一类似?)，方便处理特殊、非法情况。
例子：
```cpp
class Solution {

public:

    int minimumTotal(vector<vector<int>>& triangle) {

        // f[i][j]: 代表到达(i, j)的最小路径和

        // f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];

        // f[i][j] 的下标整体 + 1, triangle下标不变，方便处理边界条件

        // 得到f[i + 1][j + 1] = min(f[i][j], f[i][j + 1]) + triangle[i][j];

        int m = triangle.size();

        int mx = triangle[m - 1].size();
		// 注意这里的初始化细节，因为取min，将非法情况设为INT_MAX / 2，因此非法情况取min时自动被过滤！！！
        vector<vector<int>> f(m + 1, vector<int>(mx + 1, INT_MAX / 2));

        for(int i = 0; i < m; i++)

        {

            int n = triangle[i].size();

            for(int j = 0; j < n; j++)

            {

                if(i == 0 && j == 0)

                {

                    f[i + 1][j + 1] = triangle[i][j];

                }

                else

                {

                    f[i + 1][j + 1] = min(f[i][j], f[i][j + 1]) + triangle[i][j];

                }

            }

        }

        int ans = INT_MAX;

        for(int i = 0; i <= mx; i++)

        {

            ans = min(ans, f[m][i]);

        }

        return ans;

  

    }

};
```