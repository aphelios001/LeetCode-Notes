未来的我，请好好回忆：
通常用来解决寻找**下一个更大/更小元素** 的问题
![[单调栈.png]]
## 个人理解：
**栈**中保留的是没有找到 下一个大于本元素的元素（也就是**没找到对应的答案**的元素）。
如果找到第一个大于它的元素（答案）了，就**弹出这个元素**（也就是说这个元素已经没用了，及时弹出）。
单调栈有点像用哈希表枚举的那种**维护左，枚举右**的思想。左就是栈中的元素，右就是当前遍历到还没入栈的元素。用右边来更新左边，同时让左边满足条件的元素出栈。我认为这就是单调栈。（个人理解， 错了再改）

## 个人理解更新（白话版本）：
单调栈分为**单调递增栈**和**单调递减栈**。（也就只有这两种）。
（我定义的是：元素从**栈底 到 栈顶**递增/递减）。

做题时要记住：
当前遍历到的元素nums[i]，一定要入栈（一定要保留），也就是你要让他入栈后，保持栈原本的单调性。
nums[i]通过与栈顶元素(假设是**st.top()**)比较，可以初步确认当前元素入栈后，是否满足栈的单调性，如果不满足，那么就要让栈顶元素出栈，直到可以保证栈满足单调性为止。
也就是说让while循环进行下去的条件，是当前元素入栈后不满足栈的单调性的判断语句。这样就会一直弹出栈顶，直到满足单调性。

注意：出栈的元素和当前元素会存在某种关系。

## DeepSeek优化表达后的版本：
单调栈分为**单调递增栈**和**单调递减栈**（仅此两种）。  
（定义：栈内元素从**栈底到栈顶**保持严格递增或递减）。

**核心操作原则**：  
遍历元素`nums[i]`时，必须将其入栈，并通过调整栈结构维持单调性。具体步骤：  
1. **比较判断**：若`nums[i]`与栈顶元素`st.top()`的比较结果**破坏当前单调性**（例如在递增栈中`nums[i] < st.top()`），则持续弹出栈顶元素，直至新元素入栈后能恢复单调性。 w 
2. **终止条件**：循环弹出的条件是`while (栈非空 && 当前元素破坏单调性)`，确保最终栈仍满足单调性。  

**关键点**：  
- 每个元素必定入栈，但可能需先弹出若干栈顶元素。  
- 破坏单调性的比较方向决定栈类型（递增栈用`<`，递减栈用`>`）。  
（注：调整仅优化表述逻辑，未改变原意。）
